HttpRunner原版已经更新到3.x了，在3.x中，debugtalk引入了pytest，在之前的版本中，HttpRunner支持两种方式的使用，
1)通过api testcase testsuite三级目录，编辑测试用例的调用关系，以命令行方式去使用；
2)把HttpRunenr作为一个第三方包，引入到其他中，通过调用HttpRunenr.run_test方法，传入必要的用例参数，可以执行测试。

在3.x版本中，除了以上两种方法，开始支持直接通过写代码的方式去执行测试，比如：
from httprunner import HttpRunner, Config, Step, RunRequest, RunTestCase

```class TestCaseRequestWithFunctions(HttpRunner):
    config = (
        Config("request methods testcase with functions")
        .variables(
            **{
                "foo1": "config_bar1",
            }
        )
        .base_url("https://postman-echo.com")
        .verify(False)
        .export(*["foo3"])
    )

    teststeps = [
        Step(
            RunRequest("get with params")
            .with_variables(
                **{"foo1": "bar11", "foo2": "bar21", "sum_v": "${sum_two(1, 2)}"}
            )
            .get("/get")
            .with_params(**{"foo1": "$foo1", "foo2": "$foo2", "sum_v": "$sum_v"})
            .extract()
            .validate()
            .assert_equal("status_code", 200)
        ),
        Step(
            RunRequest("post form data")
            .with_variables(**{"foo2": "bar23"})
            .post("/post")
            .with_headers(
                **{"User-Agent": "HttpRunner/${get_httprunner_version()}",}
            )
            .validate()
            .assert_equal("status_code", 200)
        ),
    ]


if __name__ == "__main__":
    TestCaseRequestWithFunctions().test_start()
```

稍微阅读了一下源码，感觉这一点理解起来比较容易，写一个类，继承HttpRunner，HttpRunner类中有个成员函数是test_start，把HttpRunner的子类作为pytest.main()的参数传递进去，pytest会自动发现
test_start方法并自动执行该方法。这样，我们只需要在子类中，修改config和teststep两个成员变量，就可以实现通过代码方式写测试用例了。

通过理解和查阅资料觉得这样写有两点好处，
一是通过代码写用例，不会担心写错 variables export等关键字，而且写用例也相对简单一些了。
二是pytest有很多好的特性，可以进行套用，比如最基本的测试报告的内容，可以通过自己写插件实现报告的多样性，还有测试日志文件地址，执行过程中异常处理等，都有一些参数配置。

java没有现成的pytest类似框架可以使用，因为2.x和3.x变化实在太大，我也想着是否可以通过一些方法也实现java版本的这些特性，最基本的是通过代码写用例，可以尝试实现一下。

挑来挑去，感觉java中junit单测框架符合自己的预期，可以实现类似手写代码的用例编写方式。

